import type { AIProvider } from '../../types/ai.js';

/**
 * Represents seasonal colors generated by AI for the Vestaboard color bar
 */
export interface SeasonalColors {
  colors: number[]; // Array of 6 color codes (63-69)
  generatedAt: Date;
  season: string; // e.g., "fall", "winter", "spring", "summer"
  holiday?: string; // e.g., "thanksgiving", "christmas" if applicable
}

/**
 * Configuration options for ColorBarService
 */
export interface ColorBarServiceConfig {
  cacheTtlMs?: number; // Default: 24 * 60 * 60 * 1000 (24 hours)
}

/**
 * Result from ColorBarService.getColors()
 */
export interface ColorResult {
  colors: number[]; // Array of 6 color codes (63-69)
  cacheHit: boolean; // True if returned from cache, false if fetched from AI
}

/**
 * Default fallback colors when AI is unavailable
 * Order: BLUE, GREEN, YELLOW, ORANGE, RED, VIOLET
 * Represents a cool-to-warm gradient suitable for all seasons
 */
export const FALLBACK_COLORS: number[] = [67, 66, 65, 64, 63, 68];

/**
 * Vestaboard color code range constants
 */
const MIN_COLOR_CODE = 63;
const MAX_COLOR_CODE = 69;
const REQUIRED_COLOR_COUNT = 6;

/**
 * Service for generating seasonal color palettes for Vestaboard frame
 * Uses Claude Haiku 4.5 AI with 24-hour caching
 * Implemented as singleton to ensure cache persistence across calls
 */
export class ColorBarService {
  private static instance: ColorBarService | null = null;
  private cache: SeasonalColors | null = null;
  private readonly cacheTtlMs: number;

  private constructor(
    private readonly aiProvider: AIProvider,
    config?: ColorBarServiceConfig
  ) {
    this.cacheTtlMs = config?.cacheTtlMs ?? 24 * 60 * 60 * 1000; // 24 hours default
  }

  /**
   * Get singleton instance of ColorBarService
   * Creates new instance if none exists, otherwise returns existing instance
   */
  public static getInstance(
    aiProvider: AIProvider,
    config?: ColorBarServiceConfig
  ): ColorBarService {
    if (!ColorBarService.instance) {
      ColorBarService.instance = new ColorBarService(aiProvider, config);
    }
    return ColorBarService.instance;
  }

  /**
   * Clear singleton instance (for test isolation)
   */
  public static clearInstance(): void {
    ColorBarService.instance = null;
  }

  /**
   * Get current seasonal colors
   * Returns cached colors if valid, otherwise fetches from AI
   * Falls back to FALLBACK_COLORS on error
   */
  async getColors(): Promise<ColorResult> {
    // Return cached colors if valid
    if (this.isCacheValid()) {
      return {
        colors: this.cache!.colors,
        cacheHit: true,
      };
    }

    // Otherwise fetch from Haiku
    try {
      const seasonalColors = await this.fetchFromHaiku();
      this.cache = seasonalColors;
      return {
        colors: seasonalColors.colors,
        cacheHit: false,
      };
    } catch (error) {
      console.error('Failed to fetch colors from AI, using fallback:', error);
      return {
        colors: FALLBACK_COLORS,
        cacheHit: false,
      };
    }
  }

  /**
   * Check if cache exists and hasn't expired
   */
  private isCacheValid(): boolean {
    if (!this.cache) {
      return false;
    }

    const now = new Date().getTime();
    const cacheAge = now - this.cache.generatedAt.getTime();
    return cacheAge < this.cacheTtlMs;
  }

  /**
   * Fetch seasonal colors from Haiku AI
   */
  private async fetchFromHaiku(): Promise<SeasonalColors> {
    const season = this.getCurrentSeason();
    const holiday = this.getCurrentHoliday();

    const prompt = this.buildPrompt(season, holiday);

    const response = await this.aiProvider.generate({
      systemPrompt: 'You are a helpful assistant that generates color palettes for displays.',
      userPrompt: prompt,
      maxTokens: 100,
      temperature: 0.7,
    });

    // Parse JSON response
    const colors = this.parseColorsResponse(response.text);

    return {
      colors,
      generatedAt: new Date(),
      season,
      holiday,
    };
  }

  /**
   * Build AI prompt for color generation
   */
  private buildPrompt(season: string, holiday?: string): string {
    const dateStr = new Date().toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });

    return `Generate a 6-color palette for a Vestaboard split-flap display's vertical color bar.

Current date: ${dateStr}
Season: ${season}
${holiday ? `Upcoming holiday: ${holiday}` : ''}

Available colors with their numeric codes:
- RED (63): Warm, energetic, holiday accent
- ORANGE (64): Autumn, warmth, enthusiasm
- YELLOW (65): Summer, sunshine, happiness
- GREEN (66): Spring, nature, growth
- BLUE (67): Winter, calm, sky
- VIOLET (68): Twilight, creativity, elegance
- WHITE (69): Snow, purity, neutral

Return ONLY a JSON array of exactly 6 numeric color codes for a vertical gradient.
Example response: [67, 66, 65, 64, 63, 68]

Consider:
- The colors will display vertically from top to bottom
- Create a pleasing gradient or thematic pattern
- Match the current season and any upcoming holidays
- Use colors that look good on a split-flap display`;
  }

  /**
   * Parse and validate color codes from AI response
   */
  private parseColorsResponse(text: string): number[] {
    try {
      const parsed = JSON.parse(text.trim());

      // Validate it's an array
      if (!Array.isArray(parsed)) {
        throw new Error('Response is not an array');
      }

      // Validate exactly 6 colors
      if (parsed.length !== REQUIRED_COLOR_COUNT) {
        throw new Error(`Expected ${REQUIRED_COLOR_COUNT} colors, got ${parsed.length}`);
      }

      // Validate all are numbers in range 63-69
      if (!parsed.every(code => this.isValidColorCode(code))) {
        throw new Error('Invalid color codes');
      }

      return parsed;
    } catch (error) {
      console.error('Failed to parse AI response, using fallback:', error);
      return FALLBACK_COLORS;
    }
  }

  /**
   * Check if a value is a valid Vestaboard color code
   */
  private isValidColorCode(code: unknown): code is number {
    return typeof code === 'number' && code >= MIN_COLOR_CODE && code <= MAX_COLOR_CODE;
  }

  /**
   * Determine current season from month
   */
  private getCurrentSeason(): string {
    const month = new Date().getMonth(); // 0-11
    if (month >= 2 && month <= 4) return 'spring'; // Mar-May
    if (month >= 5 && month <= 7) return 'summer'; // Jun-Aug
    if (month >= 8 && month <= 10) return 'fall'; // Sep-Nov
    return 'winter'; // Dec-Feb
  }

  /**
   * Check for upcoming holidays within 7 days
   */
  private getCurrentHoliday(): string | undefined {
    const now = new Date();
    const month = now.getMonth();
    const day = now.getDate();

    // Check for holidays within date ranges
    if (month === 11 && day >= 18 && day <= 25) return 'christmas';
    if (month === 10 && day >= 20 && day <= 28) return 'thanksgiving';
    if (month === 9 && day >= 24 && day <= 31) return 'halloween';
    if (month === 6 && day >= 1 && day <= 7) return 'independence-day';
    if (month === 1 && day >= 7 && day <= 14) return 'valentines-day';
    if (month === 2 && day >= 10 && day <= 17) return 'st-patricks-day';

    return undefined;
  }

  /**
   * Clear the cache, forcing next getColors() to fetch fresh data
   */
  clearCache(): void {
    this.cache = null;
  }
}
