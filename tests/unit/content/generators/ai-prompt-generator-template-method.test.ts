/**
 * Tests for AIPromptGenerator Template Method Pattern
 *
 * These tests validate the Template Method pattern refactoring that:
 * - Centralizes promptsOnly handling in ONE place (base generate())
 * - Provides clean extension hooks for subclasses
 * - Prevents subclasses from overriding the full generate() method
 *
 * Test coverage:
 * - getTemplateVariables() hook for custom template variables
 * - getCustomMetadata() hook for generator-specific metadata
 * - postProcessContent() hook for content modification
 * - Centralized promptsOnly handling
 * - Hook execution order verification
 */

import {
  AIPromptGenerator,
  type AIProviderAPIKeys,
} from '@/content/generators/ai-prompt-generator';
import { PromptLoader } from '@/content/prompt-loader';
import { ModelTierSelector } from '@/api/ai/model-tier-selector';
import type { GenerationContext, GeneratedContent } from '@/types/content-generator';
import { ModelTier } from '@/types/content-generator';
import { createMockAIProvider } from '@tests/__helpers__/mockAIProvider';

// Mock createAIProvider function
jest.mock('@/api/ai/index.js', () => ({
  createAIProvider: jest.fn((provider: string, _apiKey: string, model: string) => {
    return createMockAIProvider({
      response: {
        text: `Generated by ${provider} with ${model}`,
        model: model,
      },
    });
  }),
  AIProviderType: {
    OPENAI: 'openai',
    ANTHROPIC: 'anthropic',
  },
}));

// Mock personality generation
jest.mock('@/content/personality/index.js', () => ({
  generatePersonalityDimensions: jest.fn(() => ({
    mood: 'cheerful',
    energyLevel: 'high',
    humorStyle: 'witty',
    obsession: 'coffee',
  })),
}));

import { createAIProvider } from '@/api/ai/index.js';

/**
 * Test implementation: Basic generator using only required methods
 */
class BasicTestGenerator extends AIPromptGenerator {
  protected getSystemPromptFile(): string {
    return 'test-system.txt';
  }

  protected getUserPromptFile(): string {
    return 'test-user.txt';
  }
}

/**
 * Test implementation: Generator with custom template variables
 * Simulates WeatherGenerator pattern - injecting external data into prompts
 */
class TemplateVariablesGenerator extends AIPromptGenerator {
  public templateVarsCallCount = 0;
  public lastContext: GenerationContext | null = null;
  private customData: Record<string, string>;

  constructor(
    promptLoader: PromptLoader,
    modelTierSelector: ModelTierSelector,
    apiKeys: AIProviderAPIKeys = {},
    customData: Record<string, string> = {}
  ) {
    super(promptLoader, modelTierSelector, ModelTier.MEDIUM, apiKeys);
    this.customData = customData;
  }

  protected getSystemPromptFile(): string {
    return 'test-system.txt';
  }

  protected getUserPromptFile(): string {
    return 'test-user.txt';
  }

  /**
   * Override hook to inject custom template variables
   */
  protected async getTemplateVariables(
    context: GenerationContext
  ): Promise<Record<string, string>> {
    this.templateVarsCallCount++;
    this.lastContext = context;
    return this.customData;
  }
}

/**
 * Test implementation: Generator with custom metadata
 * Simulates generators that need to track generator-specific info
 */
class CustomMetadataGenerator extends AIPromptGenerator {
  public metadataCallCount = 0;
  private extraMetadata: Record<string, unknown>;

  constructor(
    promptLoader: PromptLoader,
    modelTierSelector: ModelTierSelector,
    apiKeys: AIProviderAPIKeys = {},
    extraMetadata: Record<string, unknown> = {}
  ) {
    super(promptLoader, modelTierSelector, ModelTier.MEDIUM, apiKeys);
    this.extraMetadata = extraMetadata;
  }

  protected getSystemPromptFile(): string {
    return 'test-system.txt';
  }

  protected getUserPromptFile(): string {
    return 'test-user.txt';
  }

  /**
   * Override hook to add custom metadata fields
   */
  protected getCustomMetadata(): Record<string, unknown> {
    this.metadataCallCount++;
    return this.extraMetadata;
  }
}

/**
 * Test implementation: Generator with post-processing
 * Simulates FortuneCookieGenerator pattern - modifying content after AI generation
 */
class PostProcessingGenerator extends AIPromptGenerator {
  public postProcessCallCount = 0;
  public lastContent: GeneratedContent | null = null;
  private titlePrefix: string;

  constructor(
    promptLoader: PromptLoader,
    modelTierSelector: ModelTierSelector,
    apiKeys: AIProviderAPIKeys = {},
    titlePrefix = 'TITLE'
  ) {
    super(promptLoader, modelTierSelector, ModelTier.MEDIUM, apiKeys);
    this.titlePrefix = titlePrefix;
  }

  protected getSystemPromptFile(): string {
    return 'test-system.txt';
  }

  protected getUserPromptFile(): string {
    return 'test-user.txt';
  }

  /**
   * Override hook to modify content after AI generation
   */
  protected postProcessContent(content: GeneratedContent): GeneratedContent {
    this.postProcessCallCount++;
    this.lastContent = { ...content };
    return {
      ...content,
      text: `${this.titlePrefix}\n${content.text}`,
      metadata: {
        ...content.metadata,
        titleInjected: true,
      },
    };
  }
}

/**
 * Test implementation: Generator using all hooks
 * Verifies hooks work together correctly
 */
class FullFeaturedGenerator extends AIPromptGenerator {
  public hookOrder: string[] = [];

  protected getSystemPromptFile(): string {
    return 'test-system.txt';
  }

  protected getUserPromptFile(): string {
    return 'test-user.txt';
  }

  protected async getTemplateVariables(
    _context: GenerationContext
  ): Promise<Record<string, string>> {
    this.hookOrder.push('getTemplateVariables');
    return { customVar: 'customValue' };
  }

  protected getCustomMetadata(): Record<string, unknown> {
    this.hookOrder.push('getCustomMetadata');
    return { customField: 'customData' };
  }

  protected postProcessContent(content: GeneratedContent): GeneratedContent {
    this.hookOrder.push('postProcessContent');
    return {
      ...content,
      text: `[PROCESSED] ${content.text}`,
    };
  }
}

describe('AIPromptGenerator Template Method Pattern', () => {
  let mockPromptLoader: jest.Mocked<PromptLoader>;
  let mockModelTierSelector: jest.Mocked<ModelTierSelector>;
  const mockApiKeys = {
    openai: 'sk-test-openai-key',
    anthropic: 'sk-ant-test-key',
  };

  const mockContext: GenerationContext = {
    updateType: 'major',
    timestamp: new Date('2025-01-15T12:00:00Z'),
  };

  beforeEach(() => {
    jest.clearAllMocks();

    mockPromptLoader = {
      loadPrompt: jest.fn(),
      loadPromptWithVariables: jest.fn(),
    } as unknown as jest.Mocked<PromptLoader>;

    mockModelTierSelector = {
      select: jest.fn().mockReturnValue({
        provider: 'openai',
        model: 'gpt-4o',
      }),
      getAlternate: jest.fn().mockReturnValue(null),
    } as unknown as jest.Mocked<ModelTierSelector>;

    mockPromptLoader.loadPromptWithVariables
      .mockResolvedValueOnce('System prompt')
      .mockResolvedValueOnce('User prompt');

    (createAIProvider as jest.Mock).mockReturnValue(
      createMockAIProvider({
        response: {
          text: 'AI generated content',
          model: 'gpt-4o',
          tokensUsed: 100,
        },
      })
    );
  });

  describe('getTemplateVariables() hook', () => {
    it('should call getTemplateVariables() hook during generate()', async () => {
      const generator = new TemplateVariablesGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        { weather: 'Sunny 72F' }
      );

      await generator.generate(mockContext);

      expect(generator.templateVarsCallCount).toBe(1);
    });

    it('should pass context to getTemplateVariables()', async () => {
      const generator = new TemplateVariablesGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        { weather: 'Sunny 72F' }
      );

      await generator.generate(mockContext);

      expect(generator.lastContext).toEqual(mockContext);
    });

    it('should merge custom template variables with base variables', async () => {
      const customData = {
        weather: 'Sunny 72F',
        location: 'New York',
      };

      const generator = new TemplateVariablesGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        customData
      );

      await generator.generate(mockContext);

      // Verify loadPromptWithVariables was called with merged variables
      const systemCall = mockPromptLoader.loadPromptWithVariables.mock.calls[0];
      const templateVars = systemCall[2];

      // Should have base personality variables
      expect(templateVars).toHaveProperty('mood');
      expect(templateVars).toHaveProperty('energyLevel');
      expect(templateVars).toHaveProperty('persona');

      // Should also have custom variables
      expect(templateVars).toHaveProperty('weather', 'Sunny 72F');
      expect(templateVars).toHaveProperty('location', 'New York');
    });

    it('should allow async operations in getTemplateVariables()', async () => {
      // Reset mocks for fresh test
      mockPromptLoader.loadPromptWithVariables.mockReset();
      mockPromptLoader.loadPromptWithVariables
        .mockResolvedValueOnce('System prompt')
        .mockResolvedValueOnce('User prompt');

      class AsyncTemplateVarsGenerator extends AIPromptGenerator {
        protected getSystemPromptFile(): string {
          return 'test-system.txt';
        }
        protected getUserPromptFile(): string {
          return 'test-user.txt';
        }
        protected async getTemplateVariables(
          _context: GenerationContext
        ): Promise<Record<string, string>> {
          // Simulate async data fetch
          await new Promise(resolve => setTimeout(resolve, 10));
          return { asyncData: 'fetched' };
        }
      }

      const generator = new AsyncTemplateVarsGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      await generator.generate(mockContext);

      const systemCall = mockPromptLoader.loadPromptWithVariables.mock.calls[0];
      const templateVars = systemCall[2];
      expect(templateVars).toHaveProperty('asyncData', 'fetched');
    });

    it('should use empty object when getTemplateVariables() not overridden', async () => {
      const generator = new BasicTestGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      await generator.generate(mockContext);

      // Only base variables should be present
      const systemCall = mockPromptLoader.loadPromptWithVariables.mock.calls[0];
      const templateVars = systemCall[2];

      expect(templateVars).toHaveProperty('mood');
      expect(templateVars).toHaveProperty('persona');
      expect(Object.keys(templateVars)).toEqual(
        expect.arrayContaining([
          'mood',
          'energyLevel',
          'humorStyle',
          'obsession',
          'date',
          'time',
          'persona',
        ])
      );
    });
  });

  describe('getCustomMetadata() hook', () => {
    it('should call getCustomMetadata() hook during generate()', async () => {
      const generator = new CustomMetadataGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        { weatherInjected: true }
      );

      await generator.generate(mockContext);

      expect(generator.metadataCallCount).toBe(1);
    });

    it('should include custom metadata in result', async () => {
      const customMetadata = {
        weatherInjected: true,
        feedUrls: ['https://example.com/rss'],
      };

      const generator = new CustomMetadataGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        customMetadata
      );

      const result = await generator.generate(mockContext);

      expect(result.metadata).toHaveProperty('weatherInjected', true);
      expect(result.metadata).toHaveProperty('feedUrls', ['https://example.com/rss']);
    });

    it('should not overwrite base metadata fields', async () => {
      const generator = new CustomMetadataGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        { model: 'custom-model' } // Attempt to overwrite base field
      );

      const result = await generator.generate(mockContext);

      // Base metadata should take precedence
      expect(result.metadata?.model).toBe('gpt-4o');
    });

    it('should return empty object when getCustomMetadata() not overridden', async () => {
      const generator = new BasicTestGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      const result = await generator.generate(mockContext);

      // Should only have base metadata fields
      expect(result.metadata).toHaveProperty('model');
      expect(result.metadata).toHaveProperty('tier');
      expect(result.metadata).toHaveProperty('provider');
      expect(result.metadata).not.toHaveProperty('weatherInjected');
    });
  });

  describe('postProcessContent() hook', () => {
    it('should call postProcessContent() hook after AI generation', async () => {
      const generator = new PostProcessingGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        'FORTUNE COOKIE'
      );

      await generator.generate(mockContext);

      expect(generator.postProcessCallCount).toBe(1);
    });

    it('should receive AI-generated content in postProcessContent()', async () => {
      const generator = new PostProcessingGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        'TITLE'
      );

      await generator.generate(mockContext);

      expect(generator.lastContent).not.toBeNull();
      expect(generator.lastContent?.text).toBe('AI generated content');
      expect(generator.lastContent?.outputMode).toBe('text');
    });

    it('should use modified content from postProcessContent()', async () => {
      const generator = new PostProcessingGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        'FORTUNE COOKIE'
      );

      const result = await generator.generate(mockContext);

      expect(result.text).toBe('FORTUNE COOKIE\nAI generated content');
      expect(result.metadata?.titleInjected).toBe(true);
    });

    it('should not call postProcessContent() when promptsOnly is true', async () => {
      const generator = new PostProcessingGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        'TITLE'
      );

      const promptsOnlyContext: GenerationContext = {
        ...mockContext,
        promptsOnly: true,
      };

      await generator.generate(promptsOnlyContext);

      expect(generator.postProcessCallCount).toBe(0);
    });

    it('should return content unchanged when postProcessContent() not overridden', async () => {
      const generator = new BasicTestGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      const result = await generator.generate(mockContext);

      expect(result.text).toBe('AI generated content');
    });
  });

  describe('promptsOnly handling (centralized)', () => {
    it('should handle promptsOnly in base generate() method', async () => {
      const generator = new BasicTestGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      const promptsOnlyContext: GenerationContext = {
        ...mockContext,
        promptsOnly: true,
      };

      const result = await generator.generate(promptsOnlyContext);

      expect(result.text).toBe('');
      expect(result.metadata?.systemPrompt).toBe('System prompt');
      expect(result.metadata?.userPrompt).toContain('User prompt');
      expect(createAIProvider).not.toHaveBeenCalled();
    });

    it('should still call getTemplateVariables() when promptsOnly', async () => {
      const generator = new TemplateVariablesGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        { weather: 'Sunny' }
      );

      const promptsOnlyContext: GenerationContext = {
        ...mockContext,
        promptsOnly: true,
      };

      await generator.generate(promptsOnlyContext);

      expect(generator.templateVarsCallCount).toBe(1);
    });

    it('should still call getCustomMetadata() when promptsOnly', async () => {
      const generator = new CustomMetadataGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        { source: 'weather-api' }
      );

      const promptsOnlyContext: GenerationContext = {
        ...mockContext,
        promptsOnly: true,
      };

      const result = await generator.generate(promptsOnlyContext);

      expect(generator.metadataCallCount).toBe(1);
      expect(result.metadata).toHaveProperty('source', 'weather-api');
    });

    it('should NOT call postProcessContent() when promptsOnly', async () => {
      const generator = new PostProcessingGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        mockApiKeys,
        'TITLE'
      );

      const promptsOnlyContext: GenerationContext = {
        ...mockContext,
        promptsOnly: true,
      };

      await generator.generate(promptsOnlyContext);

      expect(generator.postProcessCallCount).toBe(0);
    });
  });

  describe('hook execution order', () => {
    it('should execute hooks in correct order: getTemplateVariables -> getCustomMetadata -> postProcessContent', async () => {
      const generator = new FullFeaturedGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      await generator.generate(mockContext);

      expect(generator.hookOrder).toEqual([
        'getTemplateVariables',
        'getCustomMetadata',
        'postProcessContent',
      ]);
    });

    it('should stop at getCustomMetadata when promptsOnly (no postProcessContent)', async () => {
      const generator = new FullFeaturedGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      const promptsOnlyContext: GenerationContext = {
        ...mockContext,
        promptsOnly: true,
      };

      await generator.generate(promptsOnlyContext);

      expect(generator.hookOrder).toEqual(['getTemplateVariables', 'getCustomMetadata']);
    });
  });

  describe('backward compatibility', () => {
    it('should work with generators that only implement required methods', async () => {
      const generator = new BasicTestGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.MEDIUM,
        mockApiKeys
      );

      const result = await generator.generate(mockContext);

      expect(result.text).toBe('AI generated content');
      expect(result.outputMode).toBe('text');
      expect(result.metadata?.model).toBe('gpt-4o');
    });

    it('should preserve existing generate() behavior for simple generators', async () => {
      const generator = new BasicTestGenerator(
        mockPromptLoader,
        mockModelTierSelector,
        ModelTier.LIGHT,
        mockApiKeys
      );

      const result = await generator.generate(mockContext);

      expect(result.metadata?.tier).toBe(ModelTier.LIGHT);
      expect(result.metadata?.personality).toEqual({
        mood: 'cheerful',
        energyLevel: 'high',
        humorStyle: 'witty',
        obsession: 'coffee',
      });
    });
  });
});
